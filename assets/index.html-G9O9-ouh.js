import{_ as a,c as t,a as r,o}from"./app-qO4zmEUw.js";const p="/Reactor+ThreadPool/EchoServer.jpg",l={};function n(i,e){return o(),t("div",null,e[0]||(e[0]=[r('<p><a href="/Reactor+ThreadPool/Reactor+ThreadPool.pdf" target="_blank">跳转</a></p><p><img src="'+p+'" alt=""></p><h2 id="核心设计思路" tabindex="-1"><a class="header-anchor" href="#核心设计思路"><span>核心设计思路</span></a></h2><p>线程分为<mark>一个IO线程</mark>和<mark>多个业务线程</mark>，IO线程主要负责epoll事件循环，业务线程主要负责处理具体的业务逻辑。</p><p>其本质就是生产者消费者模型：</p><p>全局维护一个任务队列TaskQueue，IO线程将任务放入队列，业务线程从队列中取出任务执行。所以在多线程环境下，任务队列尤其重要，他是连接IO线程和业务线程的桥梁。</p><p>此时，IO线程是生产者，业务线程是消费者。</p><p>这里涉及到多线程对同一个任务队列的并发访问，为了保证线程安全，需要使用互斥锁和条件变量。</p><p>只有IO线程具备接收和发送数据的能力，当业务线程执行完任务后，需要通知IO线程，发送数据。</p><p>所以为了只让IO线程执行IO操作，在EventLoop上设计了一个_pendings变量，用来存放业务线程包装好的数据和回调函数。</p><p>从这个角度而言，业务线程成为了生产者，IO线程成为了消费者，所以_penddings也是IO线程和业务线程的桥梁，它也需要上锁。</p><p>这里就涉及到两个问题：</p><ol><li>如果epoll_wait没有设置超时时间，那么IO线程会一直阻塞，_pendings中的数据，无法及时处理。</li><li>即便epoll_wait设置了超时时间，每次循环都需要访问_pendings查看是否有数据，争取锁的过程严重影响效率。</li></ol><p>所以，eventfd成为了解决问题的关键。</p><p>epoll可以监听eventfd，当业务线程向eventfd写入数据时，IO线程就可以被唤醒。并且跳入_pendings的处理逻辑。</p>',15)]))}const s=a(l,[["render",n],["__file","index.html.vue"]]),d=JSON.parse('{"path":"/article/h0v6tjey/","title":"Reactor+ThreadPool","lang":"zh-CN","frontmatter":{"title":"Reactor+ThreadPool","createTime":"2025/02/22 11:24:40","permalink":"/article/h0v6tjey/","tags":["未完待续"]},"headers":[],"readingTime":{"minutes":1.6,"words":480},"git":{"updatedTime":1740307684000,"contributors":[{"name":"maxxwellatcher","username":"maxxwellatcher","email":"916284547@qq.com","commits":2,"avatar":"https://avatars.githubusercontent.com/maxxwellatcher?v=4","url":"https://github.com/maxxwellatcher"}]},"filePathRelative":"Linux/Reactor+ThreadPool.md","categoryList":[{"id":"edc9f0","sort":10004,"name":"Linux"}]}');export{s as comp,d as data};
