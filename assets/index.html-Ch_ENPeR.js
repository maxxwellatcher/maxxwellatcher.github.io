import{_ as i,c as o,a as l,o as s}from"./app-qO4zmEUw.js";const n={};function a(t,e){return s(),o("div",null,e[0]||(e[0]=[l(`<h2 id="cookie" tabindex="-1"><a class="header-anchor" href="#cookie"><span>Cookie</span></a></h2><p>HTTP 协议是无状态的，也就是一个请求对应一个响应。所以对于服务端而言，每次请求都是独立的，请求之间没有任何关联。这种特性就非常不利于个人用户体验。因为对于页面上某些用户偏好（例如语言、主题、定制化内容、身份认证），并不需要每次发送请求都携带这些信息。cookie 可以临时存储这些数据。<u>一个 cookie 从数据上来说就是</u><strong><u>一个附带重要属性的键值对。</u></strong></p><p>和<code>LocalStorage</code>、<code>SessionStorage</code>的区别：</p><ul><li>Cookie 适合小型数据存储和与服务器交互的场景。</li><li>LocalStorage 适合持久化存储较大数据。</li><li>SessionStorage 适合临时存储会话数据。</li></ul><p>选择哪种存储方式取决于具体的应用场景和需求。</p><p>响应头设置：</p><div class="language-http line-numbers-mode" data-ext="http" data-title="http"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>set-cookie: token=123456; path=/; max-age=3600; httponly</span></span>
<span class="line"><span># 处理第一个key=value，其他设置可选，且顺序不定</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>浏览器接收到响应头的一个 set-cookie，则会创建一个 Cookie。</p><div class="language-plain line-numbers-mode" data-ext="plain" data-title="plain"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>key: token</span></span>
<span class="line"><span>value: 123456</span></span>
<span class="line"><span>domain: yuanjin.tech # 域名</span></span>
<span class="line"><span>path: / # 基路径</span></span>
<span class="line"><span>expire: 2020-04-17 18:55:00 # 设置该cookie的过期时间</span></span>
<span class="line"><span>secure: false  # 任何请求都可以附带这个cookie，只要满足其他要求</span></span>
<span class="line"><span>httponly: true # 不允许JS获取该cookie</span></span>
<span class="line"><span>signed: true # 设置是否为签名cookie（可以验证cookie是否被篡改）</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>浏览器对 cookie 的行为：</p><ol><li>浏览器将 <strong>key/path/domain</strong> 一样的 cookie 视为相同的 cookie，其余都是附带信息。每次服务端发来相同的 cookie，都会用新的附带信息覆盖旧的附带信息。</li><li>只要 cookie 符合要求（domain/path/expire 等），则浏览器的每次请求都会自动附带在请求头上 <code>cookie: token=123; ...</code></li><li>cookie 记录的时间过期了，就会浏览器就会自动删除 cookie。针对这一点，服务器想要删除浏览器的 cookie，只需要设置一个过期的 cookie 即可。</li></ol><p>注意：Cookie 本身只是一个响应头或者请求头的一项键值对，而浏览器对 Cookie 有比较完善的机制进行处理，其他终端软件并不一定有，所以通常还会在 头部加上 <code>authorization: value</code>一项进行认证。</p><h2 id="和localstorage、sessionstorage的区别" tabindex="-1"><a class="header-anchor" href="#和localstorage、sessionstorage的区别"><span>和<code>LocalStorage</code>、<code>SessionStorage</code>的区别</span></a></h2><hr><p><strong>生命周期</strong></p><ul><li><strong>Cookie</strong>： <ul><li>可以设置过期时间（通过 <code>Expires</code> 或 <code>Max-Age</code> 属性）。</li><li>如果没有设置过期时间，则为会话 Cookie，浏览器关闭后失效。</li></ul></li><li><strong>LocalStorage</strong>： <ul><li>永久存储，除非手动清除（通过代码或浏览器设置）。</li></ul></li><li><strong>SessionStorage</strong>： <ul><li>仅在当前会话有效，关闭浏览器标签页或窗口后数据会被清除。</li></ul></li></ul><hr><p><strong>存储大小</strong></p><ul><li><strong>Cookie</strong>： <ul><li>每个 Cookie 最大 4KB，每个域名下的 Cookie 总数有限制（通常为 20-50 个，具体取决于浏览器）。</li></ul></li><li><strong>LocalStorage</strong>： <ul><li>通常为 5MB 或更多（取决于浏览器）。</li></ul></li><li><strong>SessionStorage</strong>： <ul><li>通常为 5MB 或更多（与 LocalStorage 类似）。</li></ul></li></ul><hr><p><strong>数据访问范围</strong></p><ul><li><strong>Cookie</strong>： <ul><li>可以设置作用域（通过 <code>Domain</code> 和 <code>Path</code> 属性），允许跨子域名访问。</li><li>会自动随请求发送到服务器（通过 HTTP 请求头）。</li></ul></li><li><strong>LocalStorage</strong>： <ul><li>仅限于当前域名，不能跨域名访问。</li><li>不会自动发送到服务器。</li></ul></li><li><strong>SessionStorage</strong>： <ul><li>仅限于当前标签页或窗口，即使是同一域名下的不同标签页也无法共享。</li><li>不会自动发送到服务器。</li></ul></li></ul><hr><p><strong>与服务器的交互</strong></p><ul><li><strong>Cookie</strong>： <ul><li>每次 HTTP 请求都会自动携带（通过 <code>Cookie</code> 请求头），除非设置了 <code>HttpOnly</code> 或 <code>Secure</code> 属性。</li></ul></li><li><strong>LocalStorage</strong> 和 <strong>SessionStorage</strong>： <ul><li>数据仅存储在浏览器端，不会自动发送到服务器。</li><li>需要前端代码显式地将数据添加到请求中（如通过 AJAX 或 Fetch API）。</li></ul></li></ul><hr><p><strong>安全性</strong></p><ul><li><strong>Cookie</strong>： <ul><li>可以通过设置 <code>HttpOnly</code> 属性防止 JavaScript 访问，增强安全性。</li><li>可以通过 <code>Secure</code> 属性限制仅通过 HTTPS 传输。</li><li>容易受到 CSRF（跨站请求伪造）攻击，需配合 <code>SameSite</code> 属性使用。</li></ul></li><li><strong>LocalStorage</strong> 和 <strong>SessionStorage</strong>： <ul><li>数据可以通过 JavaScript 访问，容易受到 XSS（跨站脚本攻击）的影响。</li><li>没有内置的安全机制，需开发者自行处理敏感数据。</li></ul></li></ul><hr><p><strong>总结</strong></p><ul><li>Cookie 适合小型数据存储和与服务器交互的场景。</li><li>LocalStorage 适合持久化存储较大数据。</li><li>SessionStorage 适合临时存储会话数据。</li><li>选择哪种存储方式取决于具体的应用场景和需求。</li></ul><h2 id="token" tabindex="-1"><a class="header-anchor" href="#token"><span>Token</span></a></h2><p>Token 是一种用于身份验证和授权的凭证，通常由服务器生成并返回给客户端。通常在 cookie 中设置。</p><p>主要场景：</p><ol><li>**身份认证。**用户登录后由服务端发送 Token，后续客户端发送请求携带该 Token，由服务端进行鉴别，常见身份认证包括 JWT（Json Web Token）</li><li>**授权。**Token 可以包含用户的权限信息，服务器根据 Token 决定用户是否有权访问特定资源。</li></ol>`,35)]))}const c=i(n,[["render",a],["__file","index.html.vue"]]),p=JSON.parse('{"path":"/article/0ii2gjs4/","title":"Cookie","lang":"zh-CN","frontmatter":{"title":"Cookie","createTime":"2025/02/10 19:00:28","permalink":"/article/0ii2gjs4/","tags":["前端"]},"headers":[],"readingTime":{"minutes":4.13,"words":1240},"git":{"updatedTime":1739189588000,"contributors":[{"name":"maxxwellatcher","username":"maxxwellatcher","email":"916284547@qq.com","commits":1,"avatar":"https://avatars.githubusercontent.com/maxxwellatcher?v=4","url":"https://github.com/maxxwellatcher"}]},"filePathRelative":"前端技术/Cookie.md","categoryList":[{"id":"40d75c","sort":10001,"name":"前端技术"}]}');export{c as comp,p as data};
